diff --git a/src/textfield.js b/src/textfield.js
index 980d466816a0a89f366ace356b765199c6f055b9..69348c97b0a3a354b2aa7f8929e2d785952e298a 100644
--- a/src/textfield.js
+++ b/src/textfield.js
@@ -546,116 +546,154 @@ if (actionsJson || legacyAction){
    3) Clicking a dropdown item opens #helpfield (centered overlay):
         __openHelp(key) does:
           - refuses if battle is active (__battleActive()).
           - closes dropdown
           - hides ONLY UI panels (stats/text/start/errors) via __hideUiPanels(true)
             while keeping #app visible (background page stays). 
           - positions #helpfield using battlefield rect when possible, else stage rect.
         Closing help restores UI panels via __hideUiPanels(false). 
 
    WHY THIS MATTERS FOR CLICK SAFETY:
      - helpfield/menu sit ABOVE statsfield in z-index and they DO accept clicks.
        When closed, they MUST be display:none, otherwise they can steal clicks.
      - __hideUiPanels stores/restores previous display values to avoid messing
        with showAfter()/hide() timing logic.
    ============================================================ */
 
 /* ================= HELP MENU (Menu.json) =================
    - Uses Menu.json (NOT Stats.json)
    - Click "?" => dropdown (character/magic/options)
    - Click item => centered help field overlay
    - Keeps background/page image visible (does NOT hide #app)
    - Hides only UI panels (statsfield/textfield/start button/errors)
    - Help field width matches battlefield when available
 =========================================================== */
 
-const HERO_MENU_URL = "./assets/Menu.json";
+const HERO_MENU_BASE_CANDIDATES = [
+  () => {
+    try{
+      if (window.HERO_ASSET_BASE) {
+        const base = String(window.HERO_ASSET_BASE);
+        return base.endsWith("/") ? base : base + "/";
+      }
+    }catch(_){}
+    return null;
+  },
+  () => "./assets/",
+  () => "https://raw.githubusercontent.com/wolf7808/Hero/main/assets/",
+  () => "https://cdn.jsdelivr.net/gh/wolf7808/Hero@main/assets/"
+];
+
+function heroMenuUrls(){
+  const seen = new Set();
+  const urls = [];
+  for (const getBase of HERO_MENU_BASE_CANDIDATES){
+    const base = getBase();
+    if (!base) continue;
+    const url = base + "Menu.json";
+    if (seen.has(url)) continue;
+    seen.add(url);
+    urls.push(url);
+  }
+  return urls;
+}
 const HERO_MENU_KEYS = ["character","magic","options"];
 const HERO_MENU_FALLBACK = {};
 
 let __heroMenuLabels = null;   // {key: label}
 let __heroMenuEl = null;       // dropdown
 let __heroHelpEl = null;       // overlay
 let __heroHelpInner = null;
 let __heroHelpOpen = false;
 let __heroHelpKey = "";
 let __menuLoadPromise = null;
 
 function __ensureMenuLabels(){
   if (!__menuLoadPromise) __menuLoadPromise = __loadMenuJson();
   return __menuLoadPromise;
 }
 
 
 //
 // ================= INVENTORY VIEWMODEL (from engine.js) =================
 // We render the Character panel from a *view model* sent by engine.js via
 // CustomEvent("hero:inventory-changed").
 //
 // Why event-based?
 //   - Keeps UI decoupled from engine internal state.
 //   - Prevents accidental breakage if engine state shape changes.
 //   - Allows future overlays (battle/help/etc.) without importing engine.
 //
 // The view model shape (see engine.js buildInventoryView()):
 //   { slots:[{slot,id,label,type,option}], equip:{1:{...},2:{...},3:{...}}, maxStrength:number }
 // =======================================================================
 let __heroInvView = { slots: [], equip: {1:{},2:{},3:{}}, spellbook: [], maxStrength: 0 };
 
 
 function __clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
 
 function __battleActive(){
   const bf = document.getElementById("battlefield");
   if (bf && bf.style.display !== "none") return true;
   try{
     return !!(window.HeroEngine && window.HeroEngine.state && window.HeroEngine.state.mode === "BATTLE");
   }catch(_){}
   return false;
 }
 
 async function __loadMenuJson(){
   if (__heroMenuLabels) return __heroMenuLabels;
   const labels = Object.create(null);
-  try{
-    const r = await fetch(HERO_MENU_URL + "?v=" + Date.now(), { cache: "no-store" });
-    if (r.ok){
-      const arr = await r.json();
-      if (!Array.isArray(arr) || !arr.length || !validateKeyedArray(arr, "Menu.json")) logWarn("Menu.json: invalid or empty");
-      if (Array.isArray(arr)){
-        for (const obj of arr){
-          if (!obj || typeof obj !== "object") continue;
-          const k = Object.keys(obj)[0];
-          if (!k) continue;
-          labels[String(k)] = String(obj[k] ?? k);
-        }
-      }
-    }
-  }catch(_){}
-  __heroMenuLabels = labels;
-  return labels;
-}
+  let lastErr = null;
+  for (const url of heroMenuUrls()){
+    try{
+      const r = await fetch(url + "?v=" + Date.now(), { cache: "no-store" });
+      if (!r.ok) {
+        lastErr = new Error("HTTP " + r.status);
+        continue;
+      }
+      const arr = await r.json();
+      if (!Array.isArray(arr) || !arr.length || !validateKeyedArray(arr, "Menu.json")) {
+        lastErr = new Error("Menu.json: invalid or empty");
+        continue;
+      }
+      for (const obj of arr){
+        if (!obj || typeof obj !== "object") continue;
+        const k = Object.keys(obj)[0];
+        if (!k) continue;
+        labels[String(k)] = String(obj[k] ?? k);
+      }
+      lastErr = null;
+      break;
+    }catch(err){
+      lastErr = err;
+    }
+  }
+  if (lastErr) logWarn("Menu.json fetch failed", lastErr);
+  __heroMenuLabels = labels;
+  return labels;
+}
 
 function __menuLabel(k){
   if (__heroMenuLabels && !__heroMenuLabels.__validated){
     const required = ["new","save","load","options","music","sfx","character","magic","delete","usage","stats","inventory","equipment","equip1","equip2","equip3","maxStrength"];
     const missing = required.filter(k => !(__heroMenuLabels && k in __heroMenuLabels));
     if (missing.length) logWarn("Menu.json: missing keys", missing);
     __heroMenuLabels.__validated = true;
   }
   k = String(k||"");
   if (__heroMenuLabels && k in __heroMenuLabels) return __heroMenuLabels[k];
   return HERO_MENU_FALLBACK[k] || k;
 }
 
 function __ensureMenuDom(){
   ensure(); // ensure sfInner exists
   if (!__heroMenuEl){
     __heroMenuEl = document.createElement("div");
     __heroMenuEl.id = "heroHelpMenu";
     __heroMenuEl.className = "helpMenu";
     __heroMenuEl.style.display = "none";
     document.body.appendChild(__heroMenuEl);
   }
   if (!__heroHelpEl){
     __heroHelpEl = document.createElement("div");
     __heroHelpEl.id = "helpfield";
