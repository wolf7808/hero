diff --git a/src/start.js b/src/start.js
index f8e8321c9e388d55ca2260cc3a162adae12901cd..84b6d3272fb33da6db3a41653c9d1cdbf9b03160 100644
--- a/src/start.js
+++ b/src/start.js
@@ -1,92 +1,153 @@
 // start.js
 // Minimal start menu: plain centered words (no background).
 // Items are read from Menu.json:
 //   {"new":"Новая игра"}, {"save":"Сохранить игру"}, {"load":"Загрузить игру"}, {"options":"Настройки"}
 // Clicking dispatches actions / events:
 //   new     -> HeroEngine.newGame(); hero:navigate-next
 //   save    -> HeroEngine.saveNow()
 //   load    -> HeroEngine.loadNow(); hero:navigate to saved page
 //   options -> hero:open-options (textfield opens its Options panel)
 (() => {
   "use strict";
 
   const __log = (window.HeroLog && window.HeroLog.make) ? window.HeroLog.make("START") : null;
   function logWarn(...args){ if (__log) __log.warn(...args); else console.warn("[START]", ...args); }
   function logError(...args){ if (__log) __log.error(...args); else console.error("[START]", ...args); }
 
-  const MENU_URL = "./assets/Menu.json";
-  const ROOT_ID = "heroStartMenu";
+  function assetBaseFromScript(fileName){
+    try{
+      const scripts = document.getElementsByTagName("script");
+      for (let i = 0; i < scripts.length; i++){
+        const src = scripts[i] && scripts[i].src ? String(scripts[i].src) : "";
+        if (!src || !src.includes(fileName)) continue;
+        const u = new URL(src, window.location.href);
+        const idx = u.pathname.lastIndexOf("/src/");
+        if (idx >= 0) return u.origin + u.pathname.slice(0, idx + 1) + "assets/";
+        const dir = u.pathname.slice(0, u.pathname.lastIndexOf("/") + 1);
+        return u.origin + dir + "assets/";
+      }
+    }catch(_){}
+    return null;
+  }
+
+  function heroAssetBase(){
+    try{
+      if (!window.HERO_ASSET_BASE) return null;
+      const base = String(window.HERO_ASSET_BASE);
+      const url = new URL(base, window.location.href);
+      if (url.origin.includes("blogspot.com")) return null;
+      return base.endsWith("/") ? base : base + "/";
+    }catch(_){}
+    return null;
+  }
+
+  const MENU_BASE_CANDIDATES = [
+    () => assetBaseFromScript("start.js"),
+    () => "https://raw.githubusercontent.com/wolf7808/hero/main/assets/",
+    () => "https://cdn.jsdelivr.net/gh/wolf7808/hero@main/assets/",
+    () => heroAssetBase(),
+    () => "./assets/",
+    () => "https://raw.githubusercontent.com/wolf7808/Hero/main/assets/",
+    () => "https://cdn.jsdelivr.net/gh/wolf7808/Hero@main/assets/"
+  ];
+
+  function menuUrls(){
+    const seen = new Set();
+    const urls = [];
+    for (const getBase of MENU_BASE_CANDIDATES){
+      const base = getBase();
+      if (!base) continue;
+      const url = base + "Menu.json";
+      if (seen.has(url)) continue;
+      seen.add(url);
+      urls.push(url);
+    }
+    return urls;
+  }
+
+  const ROOT_ID = "heroStartMenu";
 
   let labels = Object.create(null);
 
   // Page readiness: index dispatches hero:page-changed. If user clicks before it arrives,
   // we queue ONE action and execute it right after the first page-changed.
   let __pageReady = false;
   let __pendingAction = null; // () => void
   let __menuRendered = false;
 
   function esc(s){
     return String(s ?? "").replace(/[&<>\"']/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[c]);
   }
 
 function validateKeyedArray(arr, context){
   if (!Array.isArray(arr)) return false;
   let ok = 0;
   for (let i = 0; i < arr.length; i++) {
     const obj = arr[i];
     if (!obj || typeof obj !== "object") {
       console.warn(context + " entry is not object at index", i);
       continue;
     }
     const k = Object.keys(obj)[0];
     if (!k) {
       console.warn(context + " entry has no key at index", i);
       continue;
     }
     ok++;
   }
   return ok > 0;
 }
 
-  async function loadMenu(){
-    try{
-      const r = await fetch(MENU_URL + "?v=" + Date.now(), { cache: "no-store" });
-      const arr = r.ok ? await r.json() : null;
-      if (!Array.isArray(arr) || !arr.length || !validateKeyedArray(arr, "Menu.json")) logWarn("Menu.json: invalid or empty");
-      if (Array.isArray(arr)){
-        const m = Object.create(null);
-        for (const it of arr){
-          if (!it || typeof it !== "object") continue;
-          const k = Object.keys(it)[0];
-          if (!k) continue;
-          m[String(k)] = String(it[k] ?? k);
-        }
-        labels = m;
-      }
-    }catch(err){ logWarn("Menu.json fetch failed", err); }
-  }
+  async function loadMenu(){
+    try{
+      const urls = menuUrls();
+      let lastErr = null;
+      for (const url of urls){
+        try{
+          const r = await fetch(url + "?v=" + Date.now(), { cache: "no-store" });
+          const arr = r.ok ? await r.json() : null;
+          if (!Array.isArray(arr) || !arr.length || !validateKeyedArray(arr, "Menu.json")) {
+            lastErr = "Menu.json: invalid or empty";
+            continue;
+          }
+          const m = Object.create(null);
+          for (const it of arr){
+            if (!it || typeof it !== "object") continue;
+            const k = Object.keys(it)[0];
+            if (!k) continue;
+            m[String(k)] = String(it[k] ?? k);
+          }
+          labels = m;
+          return;
+        }catch(err){
+          lastErr = err;
+        }
+      }
+      if (lastErr) logWarn("Menu.json fetch failed", lastErr);
+    }catch(err){ logWarn("Menu.json fetch failed", err); }
+  }
 
   function ensureRoot(){
     let el = document.getElementById(ROOT_ID);
     if (el) return el;
 
     el = document.createElement("div");
     el.id = ROOT_ID;
     el.style.position = "fixed";
     el.style.left = "50%";
     el.style.top = "50%";
     el.style.transform = "translate(-50%, -50%)";
     el.style.zIndex = "10060"; // below help dropdown (10080), above page
     el.style.display = "none";
     el.style.pointerEvents = "auto";
     el.style.textAlign = "center";
     el.style.userSelect = "none";
     document.body.appendChild(el);
     return el;
   }
 
   function label(k){
     return labels[k] || k;
   }
 
   function checkMenuVisible(reason, expectVisible){
